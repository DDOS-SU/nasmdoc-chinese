10.1 普遍性的问题.
======


10.1.1 NASM 产生了低效的代码.
======

我得到了很多关于 NASM 产生了低效代码的 BUG 报告，甚至是产生错误代码，比如像指令`ADD ESP，8`产生的代码.其实这是一个经过深思熟虑设计特性，跟可预测的输出相关:NASM 看到`ADD ESP，8`时，会产生一个预留 32 位偏移的指令形式.如果你希望产生一个节约空间的指令形式，你必须写上`ADD ESP，BYTE 8`.这不是一个 BUG，至多也只能算是一个不好的特性，各人看法不同而已.

10.1.2 我的 jump 指令超出范围.
======

相似的，人们经常抱怨说在他们使用条件跳转指令时(这些指令缺省状况下是`short`的)经常需要跳转比较远，而 NASM 会报告说`short jump out of range`，而不作长远转.同样，这也是可预测执行的一个部分，但实际上还有一个更有实际的理由.NASM 没有办法知道它产生的代码运行的处理器的类型;

所以它自己不能决定它应该产生`Jcc NEAR`类型的指令，因为它不知道它正在 386 或更高一级的处理器上工作.相反，它把可能超出范围的短`JNE`指令替换成一个很短的`JE`指令，这个指令仅仅跳过一个`JMP NEAR`指令;

对于低于 386 的处理器，这是一个可行的解决方案，但是对于有较好的分支预测功能的处理器很难有较好的效果，所以可代之以`JNE NEAR`.所以，产生什么的指令还是取决于用户，而不是汇编器本身.

10.1.3 `ORG`不正常工作.
======

那些用`bin`格式写引导扇区代码的人们经常抱怨`ORG`没有按他们所希望的那样正常工作:为了把`0xAA55`放到 512 字节的引导扇区的末尾，使用 NASM 的人们会这样写:

```nasm
        ORG 0 

        ; some boot sector code 

        ORG 510 
        DW 0xAA55
```

这不是 NASM 中使用`ORG`的正确方式，不会正常工作.解决这个问题的正确方法是使用`TIMES`操作符，就象这样:

```nasm
        ORG 0 

        ; some boot sector code 

        TIMES 510-($-$$) DB 0 
        DW 0xAA55
```

`TIME`操作符会在输出中插入足够数量的零把汇编点移到 510.这种办法还有一个好处，如果你意外地在你的引导扇区中放入了太多的内容，以致超出容量，NASM 会在汇编时检测到这个错误，并报告.所以你最终就不必重汇编并去找出错误所在.

10.1.4 `TIMES`不正常工作.
======

关于上面代码的另一个普遍性的问题是，有人这样写`TIMES`这一行:

```nasm
      TIMES 510-$ DB 0
```

因为`$`是一个纯数字，就像 510，所以它们相减的值也是一个纯数字，可以很好地被 TIMES 使用.NASM 是一个模块化的汇编器:不同的组成部分被设计为可以很容易的单独重用，所以它们不会交换一些不必要的信息.结果，`BIN`输出格式尽管被`ORG`告知`.text`段应当在 0 处开始，但是不会把这条信息传给表达式的求值程序.所以对求值程序来讲，`$`不是一个纯数值:它是一个从一个段基址开始的偏移值.因为`$`和 510之间的计算结果也不是一个纯数，而是含有一个段基址.含有一个段基址的结果是不能作为参数传递给`TIMES`的.解决方案就象上一节所描述的，应该如下:

```nasm
       TIMES 510-($-$$) DB 0
```

在这里，`$`和`$$`是从同一个段基址的偏移，所以它们相减的结果是一个纯数，这句代码会解决上述问题，并产生正确的代码.
