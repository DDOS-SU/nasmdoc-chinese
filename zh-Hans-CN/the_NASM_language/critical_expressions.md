3.8 临界表达式。
======

NASM 的一个限制是它是一个两遍的汇编器;不像 TASM 和其它汇编器，它总是只做两遍汇编。

所以它就不能处理那些非常复杂的需要三遍甚至更多遍汇编的源代码。

第一遍汇编是用于确定所有的代码与数据的尺寸大小，这样的话，在第二遍产生代码的时候，就可以知道代码引用的所有符号地址。

所以，有一件事NASM不能处理，那就是一段代码的尺寸依赖于另一个符号值，而这个符号又在这段代码的后面被声明。

比如:

```nasm
               times (label-$) db 0 
       label:  db      'Where am I?'
```

`TIMES`的参数本来是可以合法得进行计算的，但 NASM 中不允许这样做，因为它在第一次看到 TIMES 时的时候并不知道它的尺寸大小。

它会拒绝这样的代码。

```nasm
               times (label-$+1) db 0 
       label:  db      'NOW where am I?'
```

在上面的代码中，`TIMES` 的参数是错误的。

NASM 使用一个叫做临界表达式的概念，以禁止上述的这些例子，临界表达式被定义为一个表达式，它所需要的值在第一遍汇编时都是可计算的，所以，该表达式所依赖的符号都是之前已经定义了的，`TIMES`前缀的参数就是一个临界表达式;

同样的原因，`RESB`类的伪指令的参数也是临界表达式。

临界表达式可能会出现下面这样的情况:

```nasm
                       mov     ax,symbol1 
       symbol1         equ     symbol2 
       symbol2:
```

在第一遍的时候，NASM 不能确定`symbol1`的值，因为`symbol1`被定义成等于`symbols2`，而这时，NASM 还没有看到 symbol2。

所以在第二遍的时候，当它遇上`mov ax，symbol1`，它不能为它产生正确的代码，因为它还没有知道`symbol1`的值。

当到达下一行的时候，它又看到了`EQU`，这时它可以确定 symbol1 的值了，但这时已经太晚了。

NASM 为了避免此类问题，把`EQU`右侧的表达式也定义为临界表达式，所以，`symbol1`的定义在第一遍的时候就会被拒绝。

这里还有一个关于前向引用的问题:考虑下面的代码段:

```nasm
               mov     eax,[ebx+offset] 
       offset  equ     10
```

NASM 在第一遍的时候，必须在不知道`offset`值的情况下计算指令`mov eax，[ebx+offset]`的尺寸大小。

它没有办法知道`offset`足够小，足以放在一个字节的偏移域中，所以，它以产生一个短形式的有效地址编码的方式来解决这个问题;

在第一遍中，它所知道的所有关于`offset`的情况是:它可能是代码段中的一个符号，而且，它可能需要四字节的形式。

所以，它强制这条指令的长度为适合四字节地址域的长度。

在第二遍的时候，这个决定已经作出了，它保持使这条指令很长，所以，这种情况下产生的代码没有足够的小，这个问题可以通过先定义 offset 的办法得到解决，或者强制有效地址的尺寸大小，象这样写代码:[byte ebx+offset]