3.4 常数
======

NASM 能理解四种不同类型的常数:数值，字符，字符串和浮点数。

## 3.4.1 数值常数。

一个数值常数就只是一个数值而已。

NASM 允许你以多种方式指定数值使用的进制，你可以以后缀`H`，`Q`，`B`来指定十六进制数，八进制数和二进制数，或者你可以用 C 风格的前缀`0x`表示十六进制数，或者以 Borland Pascal 风格的前缀`$`来表示十六进制数，注意，`$`前缀在标识符中具有双重职责(参阅 3.1)，所以一个以`$`作前缀的十六进制数值必须在`$`后紧跟数字，而不是字符。

请看一些例子:

```nasm
               mov     ax,100          ; decimal 
               mov     ax,0a2h         ; hex 
               mov     ax,$0a2         ; hex again: the 0 is required 
               mov     ax,0xa2         ; hex yet again 
               mov     ax,777q         ; octal 
               mov     ax,777o         ; octal again 
               mov     ax,10010011b    ; binary
```

## 3.4.2 字符型常数。

一个字符常数最多由包含在双引号或单引号中的四个字符组成。

引号的类型与使用跟 NASM 其它地方没什么区别，但有一点，单引号中允许有双引号出现。

一个具有多个字符的字符常数会被 little-endian order，如果你编写:

```nasm
       mov eax，'abcd'
```

产生的常数不会是`0x61626364`，而是`0x64636261`，所以你把常数存入内存的话，它会读成`abcd`而不是`dcba`。

这也是奔腾的`CPUID`指令理解的字符常数形式(参阅 B.4.34)

## 3.4.3 字符串常数。

字符串常数一般只被一些伪操作指令接受，比如`DB`类，还有`INCBIN`。

一个字符串常数和字符常数看上去很相像，但会长一些。

它被处理成最大长度的字符常数之间的连接。

所以，以下两个语句是等价的:

```nasm
             db    'hello'               ; string constant 
             db    'h','e','l','l','o'   ; equivalent character constants
```

还有，下面的也是等价的:

```nasm
             dd    'ninechars'           ; doubleword string constant 
             dd    'nine','char','s'     ; becomes three doublewords 
             db    'ninechars',0,0,0     ; and really looks like this
```

注意，如果作为`db`的操作数，类似`ab`的常数会被处理成字符串常量，因为它作为字符常数的话，还不够短，因为，如果不这样，那`db'ab`会跟`db'a`具有同样的效果，那是很愚蠢的。

同样的，三字符或四字符常数会在作为`dw`的操作数时被处理成字符串。

## 3.4.4 浮点常量

浮点常量只在作为`DD`，`DQ`，`DT`的操作数时被接受。

它们以传统的形式表达:数值，然后一个句点，然后是可选的更多的数值，然后是选项`E`跟上一个指数。

句点是强制必须有的，这样，NASM 就可以把它们跟`dd 1`区分开，它只是声明一个整型常数，而`dd 1.0`声明一个浮点型常数。

一些例子:

```nasm
             dd    1.2                     ; an easy one 
             dq    1.e10                   ; 10,000,000,000 
             dq    1.e+10                  ; synonymous with 1.e10 
             dq    1.e-10                  ; 0.000 000 000 1 
             dt    3.141592653589793238462 ; pi
```

NASM 不能在编译时求浮点常数的值。

这是因为 NASM 被设计为可移植的，尽管它常产生 x86 处理器上的代码，汇编器本身却可以和 ANSI C 编译器一起运行在任何系统上。

所以，汇编器不能保证系统上总存在一个能处理 Intel 浮点数的浮点单元。

所以，NASM 为了能够处理浮点运算，它必须含有它自己的一套完整的浮点处理例程，它大大增加了汇编器的大小，却获得了并不多的好处。