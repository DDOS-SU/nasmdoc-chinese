3.5 表达式
======

NASM 中的表达式语法跟 C 里的是非常相似的。

NASM 不能确定编译时在计算表达式时的整型数尺寸:因为 NASM 可以在 64 位系统上非常好的编译和运行，不要假设表达式总是在 32 位的寄存器中被计算的，所以要慎重地对待整型数溢出的情况。

它并不总能正常的工作。

NASM 唯一能够保证的是:你至少拥有 32 位长度。

NASM 在表达式中支持两个特殊的记号，即`$`和`$$`，它们允许引用当前指令的地址。

`$`计算得到它本身所在源代码行的开始处的地址;

所以你可以简单地写这样的代码`JMP $`来表示无限循环。

`$$`计算当前段开始处的地址，所以你可以通过 `($-$$)` 找出你当前在段内的偏移。

NASM 提供的运算符以运算优先级为序列举如下:

## 3.5.1 `|`: 位或运算符。

运算符`|`给出一个位级的或运算，所执行的操作与机器指令`or`是完全相同的。

位或是 NASM 中优先级最低的运算符。

## 3.5.2 `^`: 位异或运算符。

`^` 提供位异或操作。

## 3.5.3 `&`: 位与运算符。

`&` 提供位与运算。

## 3.5.4 `<<` and `>>`: 位移运算符。

`<<` 提供位左移， 跟 C 中的实现一样，所以`5<<3`相当于把 5 乘上 8。

`>>`提供位右移。

在 NASM 中，这样的位移总是无符号的，所以位移后，左侧总是以零填充，并不会有符号扩展。

## 3.5.5 `+` and `-`: 加与减运算符。

`+`与`-`运算符提供完整的普通加减法功能。

## 3.5.6 `*`， `/`， `//`， `%`和`%%`: 乘除法运算符。

`*`是乘法运算符。

`/`和`//`都是除法运算符，`/`是无符号除，`//`是带符号除。

同样的，`%`和`%%`提供无符号与带符号的模运算。

同 ANSI C 一样，NASM 不保证对带符号模操作执行的操作的有效性。

因为`%`符号也被宏预处理器使用，你必须保证不管是带符号还是无符号的模操作符都必须跟有空格。

## 3.5.7 一元运算符: `+`， `-`， `~`和`SEG`

这些只作用于一个参数的一元运算符是 NASM 的表达式语法中优先级最高的。

`-`把它的操作数取反，`+`不作任何事情(它只是为了和`-`保持对称)，`~`对它的操作数取补码，而`SEG`提供它的操作数的段地址(在 3.6 中会有详细解释)。