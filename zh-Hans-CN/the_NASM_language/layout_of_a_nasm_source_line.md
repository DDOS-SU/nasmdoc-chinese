3.1 NASM 源程序行的组成。
======

就像很多其他的汇编器，每一行 NASM 源代码包含(x非它是一个宏，一个预处理操作符，或一个汇编器操作符，参况第 4，5 章)下面四个部分的全部或某几个部分:

```nasm
       label:    instruction operands        ; comment
```

通常，这些域的大部分是可选的;label，instruction，comment 存在或不存在都是允许的。

当然，operands 域会因为 instruction 域的要求而必需存或必须不存在。

NASM 使用反斜线(\)作为续行符;

如果一个以一个反斜线结束，那第二行会被认为是前面一行的一部分。

NASM 对于一行中的空格符并没有严格的限制:labels 可以在它们的前面有空格，或其他任何东西。

label 后面的冒号同样也是可选的。

(注意到，这意味着如果你想要写一行`lodsb`，但却错误地写成了`lodab`，这仍将是有效的一行，但这一行不做任何事情，只是定义了一个 label。

运行 NASM 时带上命令行选项`-w+orphan-labels`会让 NASM 在你定义了一个不以冒号结尾的 label 时警告你。

labels 中的有效的字符是字母，数字，`-`，`$`，`#`，`@`，`~`，`.`和`?`。

但只有字母`.`，(具有特殊含义，参阅 3.9)，`_`和`?`可以作为标识符的开头。

一个标识符还可以加上一个`$`前缀，以表明它被作为一个标识符而不是保留字来处理。

这样的话，如果你想到链接进来的其他模块中定义了一个符号叫`eax`，你可以用`$eax`在NASM 代码中引用它，以和寄存器的符号区分开。

instruction 域可以包含任何机器指令:Pentium 和 P6 指令，FPU 指令，MMX 指令还有甚至没有公开的指令也会被支持。

这些指令可以加上前缀`LOCK`，`REP`，`REPE/REPZ`或`REPNE`/`REPNZ`，通常，支持显示的地址尺寸和操作数尺寸前缀`A16`，`A32`，`O16`和`O32`。

关于使用它们的一个例子在第九章给出。

你也可以使用段寄存器名作为指令前缀: 代码`es mov [bx]，ax`等效于代码`mov [es:bx]，ax`。

我们推荐后一种语法。因为它和语法中的其它语法特性一致。

但是对于象`LODSB`这样的指令，它没有操作数，但还是可以有一个段前缀， 对于`es lodsb`没有清晰地语法处理方式在使用一个前缀时，指令不是必须的，像`CS`，`A32`，`LOCK`或`REPE`这样的段前缀可以单独出现在一行上，NASM 仅仅产生一个前缀字节。

作为对实际机器指令的扩展，NASM 同时提供了一定数量的伪操作指令，这在 3.2 节详细描述。

指令操作数可以使用一定的格式:它们可以是寄存器，仅仅以寄存器名来表示(比如:`ax`，`bp`，`ebx`，`cr0`:NASM 不使用`gas`的语法风格，在这种风格中，寄存器名前必须加上一个`%`符号)，或者它们可以是有效的地址(参阅 3.3)，常数(3.4)，或表达式。

对于浮点指令，NASM 接受各种语法:你可以使用 MASM 支持的双操作数形式，或者你可以使用 NASM 的在大多数情况下全用的单操作数形式。

支持的所以指令的语法细节可以参阅附录 B。

比如，你可以写:

```nasm

               fadd    st1             ; this sets st0 := st0 + st1 
               fadd    st0,st1         ; so does this 
       
               fadd    st1,st0         ; this sets st1 := st1 + st0 
               fadd    to st1          ; so does this

```

几乎所有的浮点指令在引用内存时必须使用以下前缀中的一个`DWORD`，`QWORD`或`TWORD`来指明它所引用的内存的尺寸。