3.3 有效地址
======

一个有效地址是一个指令的操作数，它是对内存的一个引用。

在 NASM 中，有效地址的语法是非常简单的:它由一个可计算的表达式组成，放在一个中括号内。

比如:

```nasm
       wordvar dw      123 
               mov     ax,[wordvar] 
               mov     ax,[wordvar+1] 
               mov     ax,[es:wordvar+bx]
```

任何与上例不一致的表达都不是 NASM 中有效的内存引用，比如:`es:wordvar[bx]`。

更复杂一些的有效地址，比如含有多个寄存器的，也是以同样的方式工作:

```nasm
               mov     eax,[ebx*2+ecx+offset] 
               mov     ax,[bp+di+8]
```

NASM 在这些有效地址上具有进行代数运算的能力，所以看似不合法的一些有效地址使用上都是没有问题的:

```nasm
           mov     eax,[ebx*5]             ; assembles as [ebx*4+ebx] 
           mov     eax,[label1*2-label2]   ; ie [label1+(label1-label2)]
```

有些形式的有效地址在汇编后具有多种形式;

在大多数情况下，NASM 会自动产生最小化的形式。

比如，32 位的有效地址`[eax*2+0]`和`[eax+eax]`在汇编后具有完全不同的形式，NASM 通常只会生成后者，因为前者会为 0 偏移多开辟 4 个字节。

NASM 具有一种隐含的机制，它会对`[eax+ebx]`和`[ebx+eax]`产生不同的操作码;

通常，这是很有用的，因为`[esi+ebp]`和`[ebp+esi]`具有不同的缺省段寄存器。

尽管如此，你也可以使用关键字`BYTE`，`WORD`，`DWORD`和`NOSPLIT`强制 NASM 产生特定形式的有效地址。

如果你想让`[eax+3]`被汇编成具有一个 double-word 的偏移域，而不是由 NASM 缺省产生一个字节的偏移。

你可以使用`[dword eax+3]`，同样，你可以强制 NASM 为一个第一遍汇编时没有看见的小值产生一个一字节的偏移(像这样的例子，可以参阅 3.8)。

比如:`[byte eax+offset]`。

有一种特殊情况，`[byte eax]`会被汇编成`[eax+0]`。

带有一个字节的 0 偏移。

而`[dwordeax]`会带一个 double-word 的 0 偏移。

而常用的形式，`[eax]`则不会带有偏移域。

当你希望在 16 位的代码中存取 32 位段中的数据时，上面所描述的形式是非常有用的。

关于这方面的更多信息，请参阅 9.2。

实际上，如果你要存取一个在已知偏移地址处的数据，而这个地址又大于 16 位值，如果你不指定一个 dword 偏移，NASM 会让高位上的偏移值丢失。

类似的，NASM 会把`[eax*2]`分裂成`[eax+eax]` ，因为这样可以让偏移域不存在以此节省空间;

实际上，它也把`[eax*2+offset]`分成`[eax+eax+offset]`，你可以使用`NOSPLIT`关键字改变这种行为:`[nosplit eax*2]`会强制`[eax*2+0]`按字面意思被处理。
