4.3 多行宏: `%macro`
======

多行宏看上去更象 MASM 和 TASM 中的宏:一个 NASM 中定义的多行宏看上去就象下面这样:

```nasm
       %macro  prologue 1 
       
               push    ebp 
               mov     ebp,esp 
               sub     esp,%1 
       
       %endmacro
```

这里，定义了一个类似 C 函数的宏 prologue:所以你可以通过一个调用来使用宏:

```nasm
       myfunc:   prologue 12
```

这会把三行代码扩展成如下的样子:

```nasm
       myfunc: push    ebp 
               mov     ebp,esp 
               sub     esp,12
```

在`%macro`一行上宏名后面的数字`1`定义了宏可以接收的参数的个数。

宏定义里面的`%1`是用来引用宏调用中的第一个参数。

对于一个有多个参数的宏，参数序列可以这样写:`%2`，`%3`等等。

多行宏就像单行宏一样，也是大小写敏感的，除非你使用另一个操作符`%imacro`如果你必须把一个逗号作为参数的一部分传递给多行宏，你可以把整个参数放在一个括号中。

所以你可以象下面这样编写代码:

```nasm
       %macro  silly 2 
       
           %2: db      %1 
       
       %endmacro 
       
               silly 'a', letter_a             ; letter_a:  db 'a' 
               silly 'ab', string_ab           ; string_ab: db 'ab' 
               silly {13,10}, crlf             ; crlf:      db 13,10
```

## 4.3.1 多行宏的重载

就象单行宏，多行宏也可以通过定义不同的参数个数对同一个宏进行多次重载。

而这次，没有对不带参数的宏的特殊处理了。

所以你可以定义:

```nasm
       %macro  prologue 0 
       
               push    ebp 
               mov     ebp,esp 
       
       %endmacro
```

作为函数 prologue 的另一种形式，它没有开辟本地栈空间。

有时候，你可能需要重载一个机器指令;

比如，你可能想定义:

```nasm
       %macro  push 2 
       
               push    %1 
               push    %2 
       
       %endmacro
```

这样，你就可以如下编写代码:

```nasm
               push    ebx             ; this line is not a macro call 
               push    eax,ecx         ; but this one is
```

通常，NASM 会对上面的第一行给出一个警告信息，因为`push`现在被定义成了一个宏，而这行给出的参数个数却不符合宏的定义。

但正确的代码还是会生成的，仅仅是给出一个警告而已。

这个警告信息可以通过`-w`macro-params`命令行选项来禁止。(参阅 2.1.17)。

## 4.3.2 Macro-Local Labels

NASM 允许你在多行宏中定义labels.使它们对于每一个宏调用来讲是本地的:所以多次调用同一个宏每次都会使用不同的 label.你可以通过在 label 名称前面加上`%%`来实现这种用法.所以，你可以创建一条指令，它可以在`Z`标志位被设置时执行`RET`指令，如下:

```nasm
       %macro  retz 0 
       
               jnz     %%skip 
               ret 
           %%skip: 
       
       %endmacro
```

你可以任意多次的调用这个宏，在你每次调用时的时候，NASM 都会为`%%skip`建立一个不同的名字来替换它现有的名字.NASM 创建的名字可能是这个样子的:`..@2345.skip`，这里的数字 2345 在每次宏调用的时候都会被修改.而`..@`前缀防止 macro-local labels 干扰本地 labels 机制，就像在 3.9 中所描述的那样.你应该避免在定义你自己的宏时使用这种形式(`..@`前缀，然后是一个数字，然后是一个句点)，因为它们会和 macro-local labels 相互产生干扰.

## 4.3.3 不确定的宏参数个数.

通常，定义一个宏，它可以在接受了前面的几个参数后， 把后面的所有参数都作为一个参数来使用，这可能是非常有用的，一个相关的例子是，一个宏可能用来写一个字符串到一个 MS-DOS 的文本文件中，这里，你可能希望这样写代码:

```nasm
               writefile [filehandle],"hello, world",13,10
```

允许你把宏的最后一个参数定义成"贪婪参数"， 也就是说你调用这个宏时，使用了比宏预期得要多得多的参数个数，那所有多出来的参数连同它们之间的逗号会被作为一个参数传递给宏中定义的最后一个实参，所以，如果你写:

```nasm
       %macro  writefile 2+ 
       
               jmp     %%endstr 
         %%str:        db      %2 
         %%endstr: 
               mov     dx,%%str 
               mov     cx,%%endstr-%%str 
               mov     bx,%1 
               mov     ah,0x40 
               int     0x21 
       
       %endmacro
```

那上面使用`writefile`的例子会如预期的那样工作:第一个逗号以前的文本[filehandle]会被作为第一个宏参数使用，会被在`%1`的所有位置上扩展，而所有剩余的文本都被合并到`%2`中，放在 db 后面.这种宏的贪婪特性在 NASM 中是通过在宏的`%macro`一行上的参数个数后面加上`+`来实现的.如果你定义了一个贪婪宏，你就等于告诉 NASM 对于那些给出超过实际需要的参数个数的宏调用该如何扩展;

 在这种情况下，比如说，NASM 现在知道了当它看到宏调用`writefile`带有 2，3 或 4 个或更多的参数的时候，该如何做.当重载宏时，NASM 会计算参数的个数，不允许你定义另一个带有 4 个参数的`writefile`宏.当然，上面的宏也可以作为一个非贪婪宏执行，在这种情况下，调用语句应该象下面这样写:
 
 ```nasm
                  writefile [filehandle], {"hello, world",13,10}
 ```
 
 NASM 提供两种机制实现把逗号放到宏参数中，你可以选择任意一种你喜欢的形式.有一个更好的办法来书写上面的宏，请参阅 5.2.1

## 4.3.4 缺省宏参数.

NASM 可以让你定义一个多行宏带有一个允许的参数个数范围.如果你这样做了，你可以为参数指定缺省值.比如:

```nasm
       %macro  die 0-1 "Painful program death has occurred." 
       
               writefile 2,%1 
               mov     ax,0x4c01 
               int     0x21 
       
       %endmacro
```

这个宏(它使用了 4.3.3 中定义的宏`writefile`)在被调用的时候可以有一个错误信息，它会在退出前被显示在错误输出流上，如果它在被调用时不带参数，它会使用在宏定义中的缺省错误信息.通常，你以这种形式指定宏参数个数的最大值与最小值;

 最小个数的参数在宏调用的时候是必须的，然后你要为其他的可选参数指定缺省值.所以，当一个宏定义以下面的行开始时:
 
 ```nasm
       %macro foobar 1-3 eax,[ebx+2]
 ```
 
  它在被调用时可以使用一到三个参数， 而`%1`在宏调用的时候必须指定，`%2`在没有被宏调用指定的时候，会被缺省地赋为`eax`，`%3`会被缺省地赋为`[ebx+2]`.你可能在宏定义时漏掉了缺省值的赋值， 在这种情况下，参数的缺省值被赋为空.这在可带有可变参数个数的宏中非常有用，因为记号`%0`可以让你确定有多少参数被真正传给了宏.这种缺省参数机制可以和`贪婪参数`机制结合起来使用;

这样上面的`die`宏可以被做得更强大，更有用，只要把第一行定义改为如下形式即可:

```nasm
       %macro die 0-1+ "Painful program death has occurred.",13,10
```

最大参数个数可以是无限，以`*`表示.在这种情况下，当然就不可能提供所有的缺省参数值. 关于这种用法的例子参见 4.3.6.

## 4.3.5 `%0`: 宏参数个数计数器.

对于一个可带有可变个数参数的宏， 参数引用`%0`会返回一个数值常量表示有多少个参数传给了宏.这可以作为`%rep`的一个参数(参阅 4.5)，以用来遍历宏的所有参数. 例子在 4.3.6 中给出.

## 4.3.6 `%rotate`: 循环移动宏参数.

Unix 的 shell 程序员对于`shift` shell 命令再熟悉不过了，它允许把传递给 shell脚本的参数序列(以`$1，`$2`等引用)左移一个，所以， 前一个参数是`$1`的话左移之后，就变成`$2`可用了，而在`$1`之前是没有可用的参数的。

NASM 具有相似的机制，使用`%rotate`。

就象这个指令的名字所表达的，它跟 Unix的`shift`是不同的，它不会让任何一个参数丢失，当一个参数被移到最左边的时候，再移动它，它就会跳到右边。

`%rotate`以单个数值作为参数进行调用(也可以是一个表达式)。

宏参数被循环左移，左移的次数正好是这个数字所指定的。

如果`%rotate`的参数是负数，那么宏参数就会被循环右移。

所以，一对用来保存和恢复寄存器值的宏可以这样写:

```nasm
       %macro  multipush 1-* 
       
         %rep  %0 
               push    %1 
         %rotate 1 
         %endrep 
       
       %endmacro
```

这个宏从左到右为它的每一个参数都依次调用指令`PUSH`。

它开始先把它的第一个参数`%1`压栈，然后调用`%rotate`把所有参数循环左移一个位置，这样一来，原来的第二个参数现在就可以用`%1`来取用了。

重复执行这个过程，直到所有的参数都被执行完(这是通过把`%0`作为`%rep`的参数来实现的)。

这就实现了把每一个参数都依次压栈。

注意，`*`也可以作为最大参数个数的一个计数，表明你在使用宏`multipush`的时候，参数个数没有上限。

使用这个宏，确实是非常方便的，执行同等的`POP`操作，我们并不需要把参数顺序倒一下。

一个完美的解决方案是，你再写一个`multipop`宏调用，然后把上面的调用中的参数复制粘贴过来就行了，这个宏会对所有的寄存器执行相反顺序的 pop 操作。

这可以通过下面定义来实现:

```nasm
       %macro  multipop 1-* 
       
         %rep %0 
         %rotate -1 
               pop     %1 
         %endrep 
       
       %endmacro
```

这个宏开始先把它的参数循环右移一个位置，这样一来，原来的最后一个参数现在可以用`%1`引用了。

然后被 pop，然后，参数序列再一次右移，倒数第二个参数变成了`%1`，就这样，所以参数被以相反的顺序一一被执行。

## 4.3.7 连结宏参数。

NASM 可以把宏参数连接到其他的文本中。

这个特性可以让你声明一个系例的符号，比如，在宏定义中。

你希望产生一个关于关键代码的表格，而代码跟在表中的偏移值有关。

你可以这样编写代码:

```nasm
       %macro keytab_entry 2 
       
           keypos%1    equ     $-keytab 
                       db      %2 
       
       %endmacro 
       
       keytab: 
                 keytab_entry F1,128+1 
                 keytab_entry F2,128+2 
                 keytab_entry Return,13
```

会被扩展成:

```nasm

       keytab: 
       keyposF1        equ     $-keytab 
                       db     128+1 
       keyposF2        equ     $-keytab 
                       db      128+2 
       keyposReturn    equ     $-keytab 
                       db      13
```

你可以很轻易地把文本连接到一个宏参数的尾部，这样写即可:`%1foo`。

如果你希望给宏参数加上一个数字，比如，通过传递参数`foo`来定义符号`foo1`和`foo2`，但你不能写成`%11`，因为这会被认为是第 11 个参数。

你必须写成`%{1}1`，它会把第一个 1 跟第二个分开这个连结特性还可以用于其他预处理问题中，比如 macro-local labels(4.3.2)和 context-local labels(4.7.2)。

{% raw %}
在所有的情况中，语法上的含糊不清都可以通过把`%`之后，文本之前的部分放在一个括号中得到解决:所以`%{%foo}bar`会把文本`bar`连接到一个 macro-local label:`%%foo`的真正名字的后面(这个是不必要的，因为就 NASM 处理 macro-local labels 的机制来讲，`%{%foo}bar`和`%%foobar `都会被扩展成同样的形式，但不管怎么样，这个连结的能力是在的)
{% endraw %}

## 4.3.8 条件代码作为宏参数。


NASM 对于含有条件代码的宏参数会作出特殊处理。

你可以以另一种形式`%+1`来使用宏参数引用`%1`，它告诉 NASM 这个宏参数含有一个条件代码，如果你调用这个宏时，参数中没有有效的条件代码，会使预处理器报错。

为了让这个特性更有用，你可以以`%-1`的形式来使用参数，它会让 NASM 把这个条件代码扩展成它的反面。

所以 4.3.2 中定义的宏`retz`还可以以下面的方式重写:

```nasm
       %macro  retc 1 
       
               j%-1    %%skip 
               ret 
         %%skip: 
       
       %endmacro
```

这个指令可以使用`retc ne`来进行调用，它会把条件跳转指令扩展成`JE`，或者`retc po`会把它扩展成`JPE`。

`%+1`的宏参数引用可以很好的把参数`CXZ`和`ECXZ`解释为有效的条件代码;

但是，`%-1`碰上上述的参数就会报错，因为这两个条件代码没有相反的情况存在。


## 4.3.9 禁止列表扩展。


当 NASM 为你的源程序产生列表文件的时候，它会在宏调用的地方为你展开多行宏，然后列出展开后的所有行。

这可以让你看到宏中的哪些指令展开成了哪些代码;

尽管如此，有些不必要的宏展开会把列表弄得很混乱。

NASM 为此提供了一个限定符`.nolist`，它可以被包含在一个宏定义中，这样，这个宏就不会在列表文件中被展开。

限定符`.nolist`直接放到参数的后面，就像下面这样:

```nasm
       %macro foo 1.nolist
```

或者这样:

```nasm
       %macro bar 1-5+.nolist a,b,c,d,e,f,g,h
```
