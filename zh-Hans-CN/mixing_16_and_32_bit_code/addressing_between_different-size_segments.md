9.2 在不同 size 的段间寻址.
======

如果你的操作系统是 16 位与 32 位混合的，或者你正在写一个 DOS 的扩展，你可能必须处理一些 16 位段和一些 32 位段.在某些地方，你可能最终要在一个 16 位段中编写能获取 32 位段中的数据的代码，或者相反.如果你要获取的 32 位段中的数据正好在段的前 64K 的范围内，你可以通过普通的16 位地址操作来达到目的;

但是或多或少，你会需要从 16 位模式中处理 32 位的寻址.最早的解决方案保证你使用了一个寄存器用于保存地址，因为任何在 32 位寄存器中的有效地址都被强制作为一个 32 位的地址，所以，你可以:

```nasm
        mov     eax,offset_into_32_bit_segment_specified_by_fs 
        mov     dword [fs:eax],0x11223344
```

这个不错，但有些笨拙(因为它浪费了一条指令和一个寄存器)，如果你已经知道你的目标所在的精确偏移.x86 架构允许 32 位有效地址被指定为一个 4bytes 的偏移，所以，NASM 为什么不为些产生一个最佳的指令呢?

它可以，就象在 9.1 中一样，你只需要在地址前加上一个`DWORD`前缀，然后，它会被强制作为一个 32 位的地址:

```nasm
        mov     dword [fs:dword my_offset],0x11223344
```

同样跟 9.1 中一样，NASM 并不关心`DWORD`前缀是在段重载符前，还是这后，所以可以把代码改得好看一些:

```nasm
       mov     dword [dword fs:my_offset],0x11223344 
```

不要把`DWROD`前缀放在方括号外面，它是用来控制存储在那里的数据的 size 的，而在方括号内的话，它控制地址本身的长度.这两种方式可以被很容易地区分:

```nasm
       mov     word [dword 0x12345678],0x9ABC
```

这把一个 16 位的数据放到了一个指定为 32 位偏移的地址中.你也可以把`WORD`或`DWROD`前缀跟`FAR`前缀放到一起，来间接跳转或调用，比如:

```nasm
       call    dword far [fs:word 0x4321]
```

这条指令包含一个指定为 16 位偏移的地址，它载入了一个 48 位的远指针，(16 位段和 32 位段偏移)，然后调用这个地址.
