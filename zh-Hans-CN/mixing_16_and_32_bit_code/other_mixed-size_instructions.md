9.3 其他的混合 size 指令.
======

你可能需要用于获取数据的其它的方式可能就是使用字符串指令(`LODSx``STOSx`，等等)或`XLATB`指令.这些指令因为不带有任何参数，看上去好像很难在它们被汇编进 16 位段的时候使它们使用 32 位地址.而这正是 NASM 的`a16`和`a32`前缀的目的，如果你正在 16 位段中编写`LODSB`，但它是被用来获取一个 32 位段中的字符串的，你应当把目标地址载入`ESI`，然后编写:

```nasm
       a32     lodsb
```

这个前缀强制地址的 size 为 32 位，意思是`LODSB`从[DS:ESI]中载入内容，而不是从[DS:SI]中.要在编写 32 位段的时候，获取在 16 位段中的字符串，相应的前缀`a16`可以被使用.`a16`和`a32`前缀可以被运用到 NASM 指令表的任何指令上，但是他们中的大多数可以在没有这两个前缀的情况下产生所有有用的形式.这两个前缀只有在那些带有隐式地址的指令中是有效的: `CMPSx` (section B.4.27)，`SCASx` (section B.4.286)， `LODSx` (section B.4.141)， `STOSx`(section B.4.303)， `MOVSx` (section B.4.178)， `INSx` (sectionB.4.121)， `OUTSx` (section B.4.195)， and `XLATB` (section B.4.334).还有，就是变量压栈与出栈指令，(`PUSHA`和`POPF` 和更常用的`PUSH`和`POP`)可以接受`a16`或`a32`前缀在堆栈段用在另一个不同 size 的代码段中的时候，强制一个特定的`SP`或`ESP`被用作栈指针，`PUSH`和`POP`，当在 32 位模式中被用在段寄存器上时，也会有一个不同的行为，它们会一次操作 4bytes，而最高处的两个被忽略，而最底部的两个给出正被操作的段寄存器的值.为了强制 push 和 pop 指令的 16 位行为，你可以使用操作数前缀`o16`

```nasm
        o16 push    ss 
        o16 push    ds
```

这段代码在栈空间中开辟一个 doubleword 用于存放两个段寄存器，而在一般情况下，这一个 doubleword 只会存放一个寄存器的值.(你也可以使用`o32`前缀在 16 位模式下强制 32 位行为，但这看上去并没有什么用处.)
